;; ****************************************************************************************************
;; chapter 13 - Database Interaction and the Application Layer

1. When we talk of a connection pool, we're essentially talking about establishing one or
more connections ahead of time and making them available to our application anytime
a database connection is required. In this way, we deal with the connection overhead
once on application startup and benefit from connection reuse from that point onward

2. jdbc/query
   jdbc/insert! jdbc/update! jdbc/delete! 
Also of note is the ! suffix on three of the API calls. This is conventionally (but not
always!) used to indicate that the function itself will perform a side effect. In the
functional programming world, this can be deemed important enough to draw extra
attention to.
Inserting, updating, and deleting will indeed result in a side effect â€“ that of changing the
persistent storage in some way. A query, by contrast, is a simple read function and will
have no effect besides data retrieval.

3. When inserting data, there are several considerations to keep in mind. If inserting
a single row, use insert!. If inserting multiple rows, use insert-multi!. If we are
interested in the generated keys, then we should favor map insertion mode. If, on
the other hand, performance is critical, we may favor vector insertion mode. When
inserting a mixture of full and partial rows, then the reader may use their personal
preference of map versus vector mode.

4. doseq can be used to iterate over a collection when we are not interested in the result (as we are when using map). 


;; ****************************************************************************************************
;; chapter 14 - HTTP with Ring

1. An important distinction to make between PUT and POST is that PUT should be used
when updating an existing resource or when we happen to know the unique ID of the
entity we're creating. POST is used solely for the creation of resources and does not
require us to know its unique ID. Instead, this ID will be allocated by the web service
itself and communicated back to the client via the response headers.
The full set of supported methods are GET, POST, PUT, DELETE, HEAD,
PATCH, CONNECT, OPTIONS, and TRACE. The first four of which are most
typically encountered.

2. JSON to EDN conversion leads to a loss of data. This is due to EDN having more built-in type
support than JSON (for example, sets and keywords)

3. Our options for parameters are path parameters or query parameters. The distinction between the two 
being that path parameters are used when they uniquely identify a resource within a collection; query
parameters are used to filter a resource by a property. As examples, we could have
the following:
"/users/123"
"/users?first-name=David"

;; *** - slurp
4. we can ingest and query users and activities via a REST web service. We'll be reading data from an incoming
body that is represented as an input stream. slurp is ideal in this case as it will open a
reader on the stream and return the stream contents as a string. slurp also works on
files, URIs, and URLs.


;; ****************************************************************************************************
;; chapter 15 - The Frontend: A ClojureScript UI

***
create a new Figwheel project using the following Leiningen command:
lein new figwheel reagent-sandbox --template-version 0.5.19 -- --reagent
***

1. A Reagent component is similar to a Hiccup component except that the first element
can be either a keyword or a function. When it's a keyword, it is a Hiccup component
and when it's a function, Reagent calls the function in order to render the component
and passes to the function the remaining parts of the vector. 

2. In Reagent, the state of the application is stored in a ratom (shorthand for reagent/ atom),
which has the same interface as regular Clojure atoms. The difference between a ratom and a Clojure 
atom is that when a ratom changes, the UI is rerendered

3. React.js embraces the functional programming approach and encourages the developer
to build their frontend application from components that manipulate data structures.
The data structures are rendered by React in the browser's Document Object Model (DOM) in a very efficient way.
React keeps the developer's mind free from having to deal with the DOM at a low level, enabling them to focus 
on the business logic.
Clojure's data-oriented approach, its immutable data structures, and the way it
manages changes via atoms make React and ClojureScript a powerful combination. 

4. when developing a React application, the developer writes React components that return data structures
and the React frameworks automatically update the DOM and render the component on the UI.

5. If a complex component's behavior is required by the application, such as doing
something special as soon as the component is mounted or just before the component
is updated, React provides lifecycle methods that the component can interact with